#Область ПрограммныйИнтерфейс

// Функция возвращает разделитель GS1.
//
// Возвращаемое значение:
//  Строка.
//
Функция РазделительGS1() Экспорт;
	
	Возврат Символ(29); // Dec 29
	
КонецФункции

// Функция возвращает экранированный символ GS1.
//
// Возвращаемое значение:
//  Строка.
//
Функция ЭкранированныйСимволGS1() Экспорт;
	
	Возврат "\x1d"; // Используется для экранирования символа GS1.
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Разбивает строку на несколько строк по указанному разделителю. Разделитель может иметь любую длину.
// В случаях, когда разделителем является строка из одного символа, и не используется параметр СокращатьНепечатаемыеСимволы,
// рекомендуется использовать функцию платформы СтрРазделить.
//
// Параметры:
//  Значение               - Строка - текст с разделителями.
//  Разделитель            - Строка - разделитель строк текста, минимум 1 символ.
//  ПропускатьПустыеСтроки - Булево - признак необходимости включения в результат пустых строк.
//    Если параметр не задан, то функция работает в режиме совместимости со своей предыдущей версией:
//     > для разделителя-пробела пустые строки не включаются в результат, для остальных разделителей пустые строки
//       включаются в результат;
//     > если параметр Строка не содержит значащих символов или не содержит ни одного символа (пустая строка), то в
//       случае разделителя-пробела результатом функции будет массив, содержащий одно значение "" (пустая строка), а
//       при других разделителях результатом функции будет пустой массив.
//  СокращатьНепечатаемыеСимволы - Булево - сокращать непечатаемые символы по краям каждой из найденных подстрок.
//
// Возвращаемое значение:
//  Массив из Строка
//
// Пример:
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(",один,,два,", ",")
//  - возвратит массив из 5 элементов, три из которых  - пустые: "", "один", "", "два", "";
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(",один,,два,", ",", Истина)
//  - возвратит массив из двух элементов: "один", "два";
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(" один   два  ", " ")
//  - возвратит массив из двух элементов: "один", "два";
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("")
//  - возвратит пустой массив;
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("",,Ложь)
//  - возвратит массив с одним элементом: ""(пустая строка);
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("", " ")
//  - возвратит массив с одним элементом: "" (пустая строка).
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Значение, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено, 
	СокращатьНепечатаемыеСимволы = Ложь) Экспорт
	
	Если СтрДлина(Разделитель) = 1 
		И ПропускатьПустыеСтроки = Неопределено 
		И СокращатьНепечатаемыеСимволы Тогда 
		
		Результат = СтрРазделить(Значение, Разделитель, Ложь);
		Для Индекс = 0 По Результат.ВГраница() Цикл
			Результат[Индекс] = СокрЛП(Результат[Индекс])
		КонецЦикла;
		Возврат Результат;
		
	КонецЕсли;
	
	Результат = Новый Массив;
	
	// Для обеспечения обратной совместимости.
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Значение) Тогда 
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = СтрНайти(Значение, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Значение, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Если СокращатьНепечатаемыеСимволы Тогда
				Результат.Добавить(СокрЛП(Подстрока));
			Иначе
				Результат.Добавить(Подстрока);
			КонецЕсли;
		КонецЕсли;
		Значение = Сред(Значение, Позиция + СтрДлина(Разделитель));
		Позиция = СтрНайти(Значение, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Значение) Тогда
		Если СокращатьНепечатаемыеСимволы Тогда
			Результат.Добавить(СокрЛП(Значение));
		Иначе
			Результат.Добавить(Значение);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
//
// Параметры:
//     СтрокаURI - Строка - ссылка на ресурс в формате:
//                          <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>.
//
// Возвращаемое значение:
//     Структура - составные части URI согласно формату:
//         * Схема         - Строка.
//         * Логин         - Строка.
//         * Пароль        - Строка.
//         * ИмяСервера    - Строка - часть <хост>:<порт> входного параметра.
//         * Хост          - Строка.
//         * Порт          - Неопределено, Число -
//         * ПутьНаСервере - Строка - часть <путь>?<параметры>#<якорь> входного параметра.
//
Функция СтруктураURI(Знач СтрокаURI) Экспорт
	
	СтрокаURI = СокрЛП(СтрокаURI);
	
	// схема
	Схема = "";
	Позиция = Найти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;

	// Строка соединения и путь на сервере.
	СтрокаСоединения = СтрокаURI;
	ПутьНаСервере = "";
	Позиция = Найти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
		
	// Информация пользователя и имя сервера.
	СтрокаАвторизации = "";
	ИмяСервера = СтрокаСоединения;
	Позиция = Найти(СтрокаСоединения, "@");
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = "";
	Позиция = Найти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// хост и порт
	Хост = ИмяСервера;
	Порт = "";
	Позиция = Найти(ИмяСервера, ":");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Логин", Логин);
	Результат.Вставить("Пароль", Пароль);
	Результат.Вставить("ИмяСервера", ИмяСервера);
	Результат.Вставить("Хост", Хост);
	Результат.Вставить("Порт", ?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
	Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
	
	Возврат Результат;
	
КонецФункции

// Возвращает Истина, если клиентское приложение является мобильным клиентом.
//
// Возвращаемое значение:
//  Булево - если нет клиентского приложения, возвращается Ложь.
//
Функция ЭтоМобильныйКлиент() Экспорт
	
#Если МобильныйКлиент Тогда
	Возврат Истина;
#ИначеЕсли Сервер Или ТолстыйКлиентОбычноеПриложение Тогда

	ЭтоМобильныйКлиент = Ложь;
	
	Если ЭтоМобильныйКлиент = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
	
	Возврат ЭтоМобильныйКлиент;
#Иначе
	Возврат Ложь;
#КонецЕсли

КонецФункции

// Создает массив и помещает в него переданное значение.
//
// Параметры:
//  Значение - Произвольный - любое значение.
//
// Возвращаемое значение:
//  Массив из Произвольный - массив из одного элемента.
//
Функция ЗначениеВМассиве(Значение) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Значение);
	
	Возврат Массив;
	
КонецФункции

// Base64 в штрихкод.
// 
// Параметры:
//  ШтрихкодВBase64 - Строка - Штрихкод в base64
// 
// Возвращаемое значение:
//  Строка - Base64 в штрихкод
Функция Base64ВШтрихкод(ШтрихкодВBase64) Экспорт
	
	ДвоичныеДанные = Base64Значение(ШтрихкодВBase64);
	Если ДвоичныеДанные = Неопределено Тогда
		Штрихкод = ШтрихкодВBase64;
	Иначе
		Штрихкод = ПолучитьСтрокуИзДвоичныхДанных(ДвоичныеДанные);
	КонецЕсли;
	
	Возврат Штрихкод;
	
КонецФункции

// Штрихкод в base64.
// 
// Параметры:
//  Штрихкод - Строка - Штрихкод
// 
// Возвращаемое значение:
//  Строка - Штрихкод в base64
Функция ШтрихкодВBase64(Штрихкод) Экспорт
	
	Если Штрихкод = Неопределено Тогда 
		ДвоичныеДанныеСтроки = Неопределено;
	Иначе
		ДвоичныеДанныеСтроки = ПолучитьДвоичныеДанныеИзСтроки(Штрихкод);
		ШтрихкодBase64 = Base64Строка(ДвоичныеДанныеСтроки);
		ШтрихкодBase64 = СтрЗаменить(ШтрихкодBase64, Символы.ПС, "");
		ШтрихкодBase64 = СтрЗаменить(ШтрихкодBase64, Символы.ВК, "");
	КонецЕсли;
	
	Возврат ШтрихкодBase64; 
	
КонецФункции

// Функция возвращает разделитель RS.
//
// Возвращаемое значение:
//  Строка.
//
Функция РазделительRS() Экспорт;
	
	Возврат Символ(30); // Dec 30
	
КонецФункции

// Функция возвращает экранированный символ RS.
//
// Возвращаемое значение:
//  Строка.
//
Функция ЭкранированныйСимволRS() Экспорт;
	
	Возврат "\x1e"; // Используется для экранирования символа RS.
	
КонецФункции  

// Функция возвращает разделитель EOT.
//
// Возвращаемое значение:
//  Строка.
//
Функция РазделительEOT() Экспорт;
	
	Возврат Символ(4); // Dec 4
	
КонецФункции

// Функция возвращает экранированный символ EOT.
//
// Возвращаемое значение:
//  Строка.
//
Функция ЭкранированныйСимволEOT() Экспорт;
	
	Возврат "\x4"; // Используется для экранирования символа EOT.
	
КонецФункции

#Область Интернет

// Создает объект описания защищенного соединения OpenSSL.
// См. также описание объекта ЗащищенноеСоединениеOpenSSL в синтаксис-помощнике.
//
// Параметры:
//  СертификатКлиента - СертификатКлиентаФайл
//                    - СертификатКлиентаWindows
//                    - Неопределено - клиентский сертификат OpenSSL.
//  СертификатыУдостоверяющихЦентров - СертификатыУдостоверяющихЦентровФайл
//                                   - СертификатыУдостоверяющихЦентровWindows
//                                   - СертификатыУдостоверяющихЦентровLinux
//                                   - СертификатыУдостоверяющихЦентровОС
//                                   - Неопределено - сертификаты удостоверяющих центров OpenSSL. 
//
// Возвращаемое значение:
//  ЗащищенноеСоединениеOpenSSL
//
Функция НовоеЗащищенноеСоединение(СертификатКлиента = Неопределено, СертификатыУдостоверяющихЦентров = Неопределено) Экспорт
	
	// АПК: 1324-выкл БСП может не использоваться
#Если ВебКлиент Тогда
	Возврат Неопределено;
#ИначеЕсли МобильныйКлиент Тогда 
	Возврат Новый ЗащищенноеСоединениеOpenSSL;
#Иначе
	Возврат Новый ЗащищенноеСоединениеOpenSSL(СертификатКлиента, СертификатыУдостоверяющихЦентров);
#КонецЕсли
	// АПК: 1324-вкл
	
КонецФункции

#КонецОбласти

// Проверяет наличие реквизита или свойства у произвольного объекта без обращения к метаданным.
//
// Параметры:
//  Объект       - Произвольный - объект, у которого нужно проверить наличие реквизита или свойства;
//  ИмяРеквизита - Строка       - имя реквизита или свойства.
//
// Возвращаемое значение:
//  Булево - Истина, если есть.
//
Функция ЕстьРеквизитИлиСвойствоОбъекта(Объект, ИмяРеквизита) Экспорт
	
	КлючУникальности   = Новый УникальныйИдентификатор;
	СтруктураРеквизита = Новый Структура(ИмяРеквизита, КлючУникальности);
	ЗаполнитьЗначенияСвойств(СтруктураРеквизита, Объект);
	
	Возврат СтруктураРеквизита[ИмяРеквизита] <> КлючУникальности;
	
КонецФункции

// Проверяет, содержит ли строка только цифры.
//
// Параметры:
//  Значение         - Строка - проверяемая строка.
//  Устаревший       - Булево - устаревший параметр, не используется.
//  ПробелыЗапрещены - Булево - если Ложь, то в строке допустимо наличие пробелов.
//
// Возвращаемое значение:
//   Булево - Истина - строка содержит только цифры или пустая, Ложь - строка содержит иные символы.
//
// Пример:
//  Результат = ТолькоЦифрыВСтроке("0123"); // Истина
//  Результат = ТолькоЦифрыВСтроке("0123abc"); // Ложь
//  Результат = ТолькоЦифрыВСтроке("01 2 3",, Ложь); // Истина
//
Функция ТолькоЦифрыВСтроке(Знач Значение, Знач Устаревший = Истина, Знач ПробелыЗапрещены = Истина) Экспорт
	
	Если ТипЗнч(Значение) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Не ПробелыЗапрещены Тогда
		Значение = СтрЗаменить(Значение, " ", "");
	КонецЕсли;
		
	Если СтрДлина(Значение) = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Если содержит только цифры, то в результате замен должна быть получена пустая строка.
	// Проверять при помощи ПустаяСтрока нельзя, так как в исходной строке могут быть пробельные символы.
	Возврат СтрДлина(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( 
			Значение, "0", ""), "1", ""), "2", ""), "3", ""), "4", ""), "5", ""), "6", ""), "7", ""), "8", ""), "9", "")) = 0;
	
КонецФункции

Функция СтрокаЗапускаБезопасная(СтрокаЗапуска) Экспорт
	// Безопасными считаются такие строковые данные, которые не содержат в себе следующие символы: "$", "`", "|", "||" ";", "&", "&&".
	ОпасныйВызов = СтрНайти(СтрокаЗапуска, "$")>0
		Или СтрНайти(СтрокаЗапуска, "`")>0
		Или СтрНайти(СтрокаЗапуска, "|")>0
		Или СтрНайти(СтрокаЗапуска, "||")>0
		Или СтрНайти(СтрокаЗапуска, ";")>0
		Или СтрНайти(СтрокаЗапуска, "&")>0
		Или СтрНайти(СтрокаЗапуска, "&&")>0;
	Возврат Не ОпасныйВызов;
КонецФункции

Функция ДатаСеанса() Экспорт
	Возврат ОбщегоНазначенияБПОСлужебныйВызовСервера.ДатаСеанса();
КонецФункции

// Преобразовать идентификатор в строку с пробелами
//
// Параметры:
//  Идентификатор - Строка - идентификатор который требуется преобразовать
//
// Возвращаемое значение:
//  Строка - идентификатор преобразованный в читаемый вид
Функция ПредставлениеИдентификатора(Идентификатор) Экспорт
	
	РазмерСтроки = СтрДлина(Идентификатор);
	Результат = "";
	Для Номер=1 По РазмерСтроки Цикл
		КодСимвола = КодСимвола(Идентификатор, Номер);
		КодСледующегоСимвола = КодСимвола(Идентификатор, Номер + 1);
		КлассСимвола = "";
		Если КодСимвола >= КодСимвола("А") И КодСимвола <= КодСимвола("Я") Тогда
			Если Номер > 1 Тогда
				Результат = Результат + " " + НРег(Символ(КодСимвола));
			Иначе
				Результат = Результат + Символ(КодСимвола);
			КонецЕсли;
		ИначеЕсли КодСимвола >= КодСимвола("а") И КодСимвола <= КодСимвола("я") Тогда
				Результат = Результат + Символ(КодСимвола);
		ИначеЕсли КодСимвола >= КодСимвола("A") И КодСимвола <= КодСимвола("Z") Тогда
			Если Номер > 1 Тогда
				КодПредыдущегоСимвола = КодСимвола(Идентификатор, Номер - 1);
				Если КодПредыдущегоСимвола >= КодСимвола("A") И КодПредыдущегоСимвола <= КодСимвола("Z") Тогда
					Результат = Результат + Символ(КодСимвола);
				ИначеЕсли КодПредыдущегоСимвола = КодСимвола("_") Тогда
					Результат = Результат + Символ(КодСимвола);
				Иначе
					Результат = Результат + " " + Символ(КодСимвола);
				КонецЕсли;
			Иначе
				Результат = Результат + Символ(КодСимвола);
			КонецЕсли;
		ИначеЕсли КодСимвола >= КодСимвола("a") И КодСимвола <= КодСимвола("z") Тогда
			Результат = Результат + Символ(КодСимвола);
		ИначеЕсли КодСимвола >= КодСимвола("0") И КодСимвола <= КодСимвола("9") Тогда
			Если Номер > 1 Тогда
				КодПредыдущегоСимвола = КодСимвола(Идентификатор, Номер - 1);
				Если КодПредыдущегоСимвола >= КодСимвола("0") И КодПредыдущегоСимвола <= КодСимвола("9") Тогда
					Результат = Результат + Символ(КодСимвола);
				ИначеЕсли КодПредыдущегоСимвола >= КодСимвола("A") И КодПредыдущегоСимвола <= КодСимвола("Z") Тогда
					Результат = Результат + Символ(КодСимвола);
				ИначеЕсли КодПредыдущегоСимвола >= КодСимвола("А") И КодПредыдущегоСимвола <= КодСимвола("Я") Тогда
					Результат = Результат + Символ(КодСимвола);
				Иначе
					Результат = Результат + " " + Символ(КодСимвола);
				КонецЕсли;
			Иначе
				Результат = Результат + Символ(КодСимвола);
			КонецЕсли;
		ИначеЕсли КодСимвола = КодСимвола("_") Тогда
			Результат = Результат + Символ(КодСимвола);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти
